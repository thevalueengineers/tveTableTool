#' identify variable type of input variables
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#' in the table.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' @param value_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. value - the values `dat`
#' 3. value label - the value labels of `dat`
#' As generated by \link[tveDataLoader]{get_valLabels}#'
#' @return named list containing flags for multi code, single code and numerics
#' @export
#'
#' @examples ''
#'
identify_var_type <- function(dat,
                              row_vars,
                              variable_labels,
                              value_labels) {

  #create data frame that detects whether multi or single code variable. Anything missing is either numeric or string.

  var_type <- value_labels %>%
    split(.$variable) |>
    purrr::map(
      ~dplyr::distinct(.x) %>%
        {
          if(all(.$value %in% c(0, 1)) & all(.$`value label` %in% c("Yes", "No"))) {
            "MC"
          } else {
            "SC"
          }
        }
    ) |>
    dplyr::bind_rows(.id = "variable") |>
    tidyr::pivot_longer(tidyselect::everything(),
                        names_to = "variable",
                        values_to = "type")

  #flag character vars in data frame - TRUE = character
  character_vars <- purrr::map_lgl(dat, ~ is.character(.x))

  #extract them from the data set so we can filter using it
  character_names <- names(dat)[character_vars]

  final_type <- variable_labels |>
    #drop respid
    dplyr::filter(variable != "respid") |>
    dplyr::left_join(var_type,dplyr::join_by("variable")) |>
    #flag character vars
    dplyr::mutate(type = ifelse(
      variable %in% character_names,"STRING",type)
    ) |>
    #anything else left is numeric
    dplyr::mutate(type = dplyr::case_when(
      is.na(type) ~ "NUM",
      TRUE ~ type
    ))

  #filter by variable type and row vars
  mc_flag <- final_type |> dplyr::filter(type == "MC") |> dplyr::filter(variable %in% row_vars) |> dplyr::pull(variable)
  single_flag <- final_type |> dplyr::filter(type == "SC") |> dplyr::filter(variable %in% row_vars) |> dplyr::pull(variable)
  numeric_flag <- final_type |> dplyr::filter(type == "NUM")  |> dplyr::filter(variable %in% row_vars) |> dplyr::pull(variable)

  return(list(
    mc_flag = mc_flag,
    single_flag = single_flag,
    numeric_flag = numeric_flag
  ))

}


#' calculate table for multi code and numeric questions
#'
#' @param dat data
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' @param flag_list named list of character vectors for single code, single code and multi code
#' As generated by \link[tveTableTool]{identify_var_type}
#'
#' @return table
#' @export
#'
#' @examples ''

mean_calcs <- function(dat,
                       col_var,
                       weight_var,
                       variable_labels,
                       flag_list) {

  # Numeric and multi-code calculations - weighted means
  number_out <- dat %>%
    # Add a specific column variable in case col_var is also selected as a row variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    dplyr::mutate(column = haven::as_factor(column)) %>%
    # Now reselect leaving out col_var unless it is in row_vars
    dplyr::select(
      dplyr::all_of(
        c(
          flag_list$numeric_flag,
          flag_list$mc_flag,
          weight_var,
          "column"
        )
      )
    ) %>%
    # Add explicit NA level
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        ~ dplyr::if_else(is.na(.), "0", as.character(.))  # Use a formula function with ~
      )
    )|>
    tidyr::pivot_longer(-c(tidyselect::all_of(weight_var), column)) |>
    #convert value to numeric so we can calculate means
    dplyr::mutate(value = as.numeric(value))

  # Weighted mean calculations
  group_number <- number_out %>%
    dplyr::group_by(name, column) %>%
    dplyr::summarise(
      value = weighted.mean(value, wt = .data[[weight_var]], na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    tidyr::pivot_wider(names_from = "column", values_from = "value")

  total_number <- number_out %>%
    dplyr::group_by(name) %>%
    dplyr::summarise(
      value = weighted.mean(value, wt = .data[[weight_var]], na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    dplyr::rename(Total = value)

  # Join them up and add label to show mean
  combined_number <- total_number %>%
    dplyr::left_join(group_number, by = "name") %>%
    dplyr::left_join(variable_labels, by = c("name" = "variable")) %>%
    dplyr::mutate(value = "mean") %>%
    dplyr::select(Variable = name, label, value, tidyselect::everything())

  return(combined_number)

}

#' calculate table for single code questions
#'
#' @param dat data
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' @param flag_list named list of character vectors for single code, single code and multi code
#' As generated by \link[tveTableTool]{identify_var_type}
#'
#' @return table
#'
#' @export
#'
#' @examples ''
#'
single_calcs <- function(dat,
                         col_var,
                         weight_var,
                         variable_labels,
                         flag_list) {

  # Prepare the data
  prep <- dat %>%
    # Add a specific column variable in case col_var is also selected as a row variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    dplyr::select(tidyselect::all_of(c(flag_list$single_flag, weight_var, "column"))) %>%
    # If labelled, convert to ordered factor
    dplyr::mutate(
      dplyr::across(
        where(labelled::is.labelled) & -tidyselect::all_of(weight_var),
        ~haven::as_factor(.x, ordered = TRUE)
      )
    ) %>%
    # Add explicit NA level
    dplyr::mutate(
      dplyr::across(
        where(labelled::is.labelled) & -tidyselect::all_of(weight_var),
        ~forcats::fct_na_value_to_level(.x)
      )
    ) %>%
    # Convert everything to character so that we can pivot longer
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        as.character
      )
    ) %>%
    tidyr::pivot_longer(-c(weight_var, column),names_to = "Variable") %>%
    # Add total column
    dplyr::bind_rows(dplyr::mutate(., column = "Total"))

  counted <-  prep %>%
    dplyr::group_by(dplyr::across(-tidyselect::all_of(weight_var))) %>%
    dplyr::count(wt = .data[[weight_var]])

  # Final transformations
  single_out <- counted %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(
      names_from = column,
      values_from = n
    ) %>%
    dplyr::left_join(variable_labels, by = c("Variable" = "variable")) %>%
    dplyr::relocate(label, .after = Variable) %>%
    dplyr::relocate(Total, .after = value) %>%
    # Replace NA with 0
    dplyr::mutate(
      dplyr::across(-c(Variable, label, value), ~tidyr::replace_na(.x, 0))
    ) %>%
    dplyr::group_by(Variable) %>%
    dplyr::mutate(dplyr::across(-c(1:2), ~.x / sum(.x, na.rm = TRUE))) %>%
    dplyr::ungroup()

  return(single_out)

}

#' wraps the 3 generate table functions into one to produce final table
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#'   in the table.
#' @param col_var Character string containing the variables to be used as
#'   columns in the output table.
#' @param weight_var Character string containing the variable name of the weight
#'   to be used.
#' @param variable_labels Either `NULL` (default) or a dataframe consisting of 2
#'   columns:
#'   1. variable - variable names from `dat`
#'   2. label - variable labels from `dat`
#'
#'   e.g. as generated by [tveDataLoader::get_varLabels()]. If `NULL`
#'   then existing variable labels will be read from `dat` using
#'   [tveDataLoader::get_varLabels()]. If a dataframe is provided then those
#'   labels will be used to replace any existing labels via
#'   [tveDataLoader::update_var_labels()]. Only the labels of variables provided
#'   will be updated, others will remain unchanged and will be used in the table
#'   as they are. As we're updating labels, every variable listed must
#'   correspond to a column in `dat`.
#' @param value_labels Either `NULL` (default) or a dataframe consisting of 3
#'   columns:
#'   1. variable - variable names from `dat`
#'   2. value - values of the variables
#'   3. value label - value labels of the values
#'
#'   e.g. as generated by [tveDataLoader::get_valLabels()]. If `NULL` then the
#'   existing value labels will be read from `dat` using
#'   [tveDataLoader::get_valLabels()]. If a dataframe is provided then those
#'   value labels will be used to replace any existing labels via
#'   [tveDataLoader::update_val_labels()]. Only the value labels of variables
#'   provided will be updated, others will remain unchanged and used in the
#'   table as they are. As we're updating labels, every variable listed must
#'   correspond to a column in `dat`.
#'
#' @return final output table
#'
#' @export
#'
#' @examples ''
#'
generate_table <- function(dat,
                           row_vars,
                           col_var,
                           weight_var,
                           variable_labels = NULL,
                           value_labels = NULL) {

  # Checks
  dat_name <- deparse(substitute(dat))
  assertthat::assert_that(is.data.frame(dat))
  assertthat::assert_that(is.character(row_vars))
  row_vars_not_in_dat <- row_vars[!row_vars %in% names(dat)]
  assertthat::assert_that(
    length(row_vars_not_in_dat) == 0,
    msg = glue::glue("row_vars are missing from {dat_name}: {stringr::str_flatten_comma(row_vars_not_in_dat)}")
  )
  assertthat::assert_that(is.character(col_var))
  assertthat::assert_that(
    col_var %in% names(dat),
    msg = glue::glue("{col_var} not in {dat_name}")
  )
  assertthat::assert_that(is.null(weight_var) || is.character(weight_var))
  if(!is.null(weight_var)) {
    assertthat::assert_that(length(weight_var) == 1, msg = "Only 1 weight variable allowed")
    assertthat::assert_that(
      weight_var %in% names(dat),
      msg = glue::glue("{weight_var} not in {dat_name}")
    )
  }
  assertthat::assert_that(
    any(
      is.null(variable_labels),
      all(
        # variable_labels should be a data frame
        is.data.frame(variable_labels),
        # all variables in variable_labels should correspond to a column in dat
        all(variable_labels[[1]] %in% names(dat))
      )
    )
  )
  assertthat::assert_that(
    any(
      is.null(value_labels),
      all(
        # value_labels should be a data frame
        is.data.frame(value_labels),
        # all variables in value_labels should correspond to a column indat
        all(unique(value_labels[[1]]) %in% names(dat))
      )
    )
  )

  # if no variable / value labels provided then read them from dat, otherwise
  # update dat with the labels provided and then read all variable / value
  # labels
  if(is.null(variable_labels)) {
    variable_labels <- tveDataLoader::get_varLabels(dat)
  } else {
    variable_labels <- dat |>
      tveDataLoader::update_var_labels(variable_labels) |>
      tveDataLoader::get_varLabels()
  }
  if(is.null(value_labels)) {
    value_labels <- tveDataLoader::get_valLabels(dat)
  } else {
    value_labels <- dat |>
      tveDataLoader::update_val_labels(value_labels) |>
      tveDataLoader::get_valLabels()
  }

  # if no weight provided (i.e. weight_var == NULL) then add a dummy weight of 1
  # and set weight_var to "weight"
  if(is.null(weight_var)) {
    dat$weight <- 1
    weight_var <- "weight"
  }

  # Identify variable types and flags
  flag_list <- identify_var_type(dat, row_vars, variable_labels, value_labels)

  # Conditional calculations for numeric and multi-code variables
  if (length(flag_list$numeric_flag) + length(flag_list$mc_flag) > 0) {
    # Numeric and multi-code calculations
    mean_calcs_result <- mean_calcs(
      dat,
      col_var,
      weight_var,
      variable_labels,
      flag_list
    )
  } else {
    mean_calcs_result <- NULL
  }

  # Conditional calculations for single-code variables
  if (length(flag_list$single_flag) > 0) {
    # Single code calculations
    single_calcs_result <- single_calcs(
      dat,
      # row_vars,
      col_var,
      weight_var,
      variable_labels,
      flag_list
    )
  } else {
    single_calcs_result <- NULL
  }

  # Store a log of the desired order based on input
  rows_order <- data.frame(Variable = row_vars, stringsAsFactors = FALSE)
  order_df <- rows_order |>
    dplyr::mutate(order = dplyr::row_number()) # Use row_number() to generate order

  # Join tables together and reorder
  output <- dplyr::bind_rows(mean_calcs_result, single_calcs_result) |>
    dplyr::left_join(order_df, by = "Variable") |>
    dplyr::arrange(order) |>
    dplyr::select(-order)

  #make sure column names have correct capitalizstion for segmentation profiling functions
  names(output) <- c("Variable", "Label", "Value", names(output)[-c(1:3)])

  # Check number of unique rows in table matches the number of row variables
  # assertthat::assert_that(length(unique(output$Variable)) == length(row_vars))

  return(output)

}


#' Classify variables by type
#'
#' @export
classify_variables <- function(loaded_data,
                               val_labels,
                               no_val_labels = NULL,
                               binary_labels = c('No' = 0, 'Yes' = 1),
                               meta_vars) {

  var_type <- val_labels |>
    _[, .N, by = c('var_name',
                   'val_label',
                   'val_value')] |>
    _[, list(valid_labels = identical(sort(val_label), names(binary_labels)),
             valid_values = identical(sort(val_value), unname(binary_labels))),
      by = 'var_name'] |>
    _[, 'type' := data.table::fifelse(valid_labels & valid_values, 'multi','single')] |>
    _[, c('valid_labels', 'valid_values') := NULL]

  if(isTRUE(!is.null(no_val_labels) && nrow(no_val_labels) > 0)) {

    var_type <- list(var_type,
                     loaded_data[, (no_val_labels[['var_name']]), with = F] |>
                       lapply(class) |>
                       lapply(data.table::as.data.table) |>
                       data.table::rbindlist(idcol = 'var_name') |>
                       data.table::setnames('V1', 'type')
    ) |>
      data.table::rbindlist()

  }

  var_type[var_name %in% meta_vars, 'type' := 'meta']

  return(var_type)

}

#' Calculate weighted means
#'
#' @export
calculate_means <- function(input_data,
                            col_var,
                            respid_var,
                            weight_var,
                            var_labels,
                            val_labels) {

  temp_data <- data.table::copy(input_data)
  temp_val_labels <- data.table::copy(val_labels)
  temp_data[, 'aux_internal_weight' := get(weight_var)] |>
    _[, (weight_var) := NULL]

  data.table::set(temp_val_labels,
                  j = 'val_value',
                  value = as.character(temp_val_labels[['val_value']]))

  var_mask <- setdiff(colnames(temp_data),
                      c(respid_var, weight_var))

  for(j in var_mask){

    data.table::set(temp_data,
                    j = j,
                    value = as.character(temp_data[[j]]))

  }

  total_means <- temp_data |>
    data.table::melt(id.vars = c(respid_var, 'aux_internal_weight', col_var),
                     variable.name = "row_variable",
                     value.name = "value",
                     variable.factor = FALSE) |>
    _[, list(total = weighted.mean(value,
                                   w = aux_internal_weight,
                                   na.rm = TRUE)),
      by = c('row_variable')] |>
    data.table::melt(id.vars = c('row_variable'),
                     measure.vars =  'total',
                     variable.name = 'col_variable',
                     value.name = 'score',
                     variable.factor = FALSE) |>
    _[, 'val_value' := NA]

  if(isFALSE(is.null(col_var))) {

    col_means <- temp_data |>
      data.table::melt(id.vars = c(respid_var, 'aux_internal_weight', col_var),
                       variable.name = "row_variable",
                       value.name = "score",
                       variable.factor = FALSE) |>
      _[, list(score = weighted.mean(score,
                                     w = aux_internal_weight,
                                     na.rm = TRUE)),
        by = c('row_variable', col_var)] |>
      data.table::melt(id.vars = c('row_variable', 'score'),
                       measure.vars =  col_var,
                       variable.name = 'col_variable',
                       value.name = 'val_value',
                       variable.factor = FALSE)

    total_means <- total_means |>
      list(col_means) |>
      data.table::rbindlist(use.names = TRUE)


  }

  output_means <- data.table::merge.data.table(total_means,
                                               temp_val_labels,
                                               by.x = c('col_variable', 'val_value'),
                                               by.y = c('var_name', 'val_value'),
                                               all.x = TRUE)

  output_means[is.na(val_label), 'val_label' := col_variable]
  output_means <- output_means |>
    data.table::dcast(row_variable ~ val_label,
                      value.var = 'score') |>
    data.table::merge.data.table(var_labels,
                                 by.x = 'row_variable',
                                 by.y = 'var_name')

  data.table::setnames(output_means,
                       c('row_variable', 'var_label', 'total'),
                       c('Variable', 'Label', 'Total'))

  data.table::setcolorder(output_means,
                          neworder = c('Variable', 'Label', 'Total'))

  return(output_means)

}

#' Calculate weighted frequencies and proportions
#'
#' @export
calculate_freqs <- function(input_data,
                            col_var,
                            respid_var,
                            weight_var,
                            var_labels,
                            val_labels) {

  temp_data <- data.table::copy(input_data)
  temp_val_labels <- data.table::copy(val_labels)
  data.table::set(temp_val_labels,
                  j = 'val_value',
                  value = as.character(temp_val_labels[['val_value']]))
  var_mask <- setdiff(colnames(temp_data),
                      c(respid_var, weight_var))

  for(j in var_mask){

    data.table::set(temp_data,
                    j = j,
                    value = as.character(temp_data[[j]]))

  }

  total_freqs <- temp_data |>
    data.table::melt(id.vars = c(respid_var, weight_var, col_var),
                     variable.name = "row_variable",
                     value.name = "row_level",
                     variable.factor = FALSE) |>
    _[, list(n = sum(get(weight_var))),
      by = c('row_variable', 'row_level')] |>
    _[, 'prop' := n/sum(n),
      by = 'row_variable'] |>
    _[, 'col_variable' := 'total'] |>
    _[, 'val_value' := NA]


  if(isFALSE(is.null(col_var))) {

    col_freqs <- temp_data |>
      data.table::melt(id.vars = c(respid_var, weight_var, col_var),
                       variable.name = "row_variable",
                       value.name = "row_level",
                       variable.factor = FALSE) |>
      _[, list(n = sum(get(weight_var))),
        by = c('row_variable', 'row_level', col_var)] |>
      _[, 'prop' := n/sum(n),
        by = c('row_variable', col_var)] |>
      data.table::melt(id.vars = c('row_variable', 'row_level', 'n', 'prop'),
                       measure.vars =  col_var,
                       variable.name = 'col_variable',
                       value.name = 'val_value',
                       variable.factor = FALSE)

    total_freqs <- total_freqs |>
      list(col_freqs) |>
      data.table::rbindlist(use.names = TRUE)


  }

  output_freqs <- data.table::merge.data.table(total_freqs,
                                               temp_val_labels,
                                               by.x = c('col_variable', 'val_value'),
                                               by.y = c('var_name', 'val_value'),
                                               all.x = TRUE)

  output_freqs[is.na(val_label), 'val_label' := col_variable]

  output_colprops <- data.table::copy(output_freqs)
  output_colprops[, 'n' := NULL]

  output_coln <- data.table::copy(output_freqs)
  output_coln[, 'prop' := NULL]

  output_colprops <- output_colprops |>
    data.table::dcast(row_variable + row_level ~ val_label,
                      value.var = c('prop')) |>
    data.table::merge.data.table(var_labels,
                                 by.x = 'row_variable',
                                 by.y = 'var_name') |>
    data.table::merge.data.table(temp_val_labels,
                                 by.x = c('row_variable', 'row_level'),
                                 by.y = c('var_name', 'val_value')) |>
    _[, 'row_level' := NULL]

  data.table::setnames(output_colprops,
                       c('row_variable', 'var_label', 'val_label', 'total'),
                       c('Variable', 'Label', 'Value', 'Total'))

  data.table::setcolorder(output_colprops,
                          neworder = c('Variable', 'Label', 'Value', 'Total'))

  output_coln <- output_coln |>
    data.table::dcast(row_variable + row_level ~ val_label,
                      value.var = c('n')) |>
    data.table::merge.data.table(var_labels,
                                 by.x = 'row_variable',
                                 by.y = 'var_name')|>
    data.table::merge.data.table(temp_val_labels,
                                 by.x = c('row_variable', 'row_level'),
                                 by.y = c('var_name', 'val_value')) |>
    _[, 'row_level' := NULL]

  data.table::setnames(output_coln,
                       c('row_variable', 'var_label', 'val_label', 'total'),
                       c('Variable', 'Label', 'Value', 'Total'))

  data.table::setcolorder(output_coln,
                          neworder = c('Variable', 'Label', 'Value', 'Total'))

  return(list(output_coln = output_coln,
              output_colprops = output_colprops))

}

#' Create all tabulations
#'
#' @export
create_tabulations <- function(loaded_data,
                               var_labels,
                               val_labels,
                               no_val_labels = NULL,
                               binary_labels = c('No' = 0, 'Yes' = 1),
                               respid_var = 'respid',
                               col_var = NULL,
                               weight_var = NULL) {

  # if no weight provided (i.e. weight_var == NULL) then add a dummy weight of 1
  # and set weight_var to "weight"
  if(isTRUE(is.null(weight_var))){
    weight_var <- "weight"
    loaded_data[, (weight_var) := 1]
  }

  meta_vars <- c(respid_var, weight_var)

  # Identify variable types
  var_types <- classify_variables(loaded_data = loaded_data,
                                  val_labels = val_labels,
                                  no_val_labels = no_val_labels,
                                  meta_vars = meta_vars,
                                  binary_labels = binary_labels)

  # subset variables by type for aggregation
  mean_dt <- var_types[type %in% c('multi', 'numeric')]
  freqs_dt <- var_types[type %in% c('single', 'multi', 'character')]

  # Conditional calculations for numeric and multi-code variables
  if(isTRUE(nrow(mean_dt) > 0)) {
    mean_mask <- c(meta_vars,
                   col_var,
                   mean_dt[['var_name']]) |>
      unique()

    # Numeric and multi-code calculations
    mean_calcs_result <- calculate_means(
      input_data = loaded_data[, ..mean_mask],
      col_var = col_var,
      respid_var = respid_var,
      weight_var = weight_var,
      val_labels = val_labels,
      var_labels = var_labels)
  } else {
    mean_calcs_result <- NULL
  }

  if(isTRUE(nrow(mean_dt) > 0)) {
    colfreq_mask <- c(meta_vars,
                      col_var,
                      freqs_dt[['var_name']]) |>
      unique()

    # Numeric and multi-code calculations
    freq_calcs_result <- calculate_freqs(
      input_data = loaded_data[, ..colfreq_mask],
      col_var = col_var,
      respid_var = respid_var,
      weight_var = weight_var,
      val_labels = val_labels,
      var_labels = var_labels)
  } else {
    freq_calcs_result <- NULL
  }

  list(
    var_types = var_types,
    means_table = mean_calcs_result,
    n_table = freq_calcs_result$output_coln,
    colprops_table = freq_calcs_result$output_colprops
  )

}







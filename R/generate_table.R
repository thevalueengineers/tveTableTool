#' Generate frequency / proportions table from survey data
#'
#' Generates a frequency (counts) or proportions (row or column percents) table
#' from a dataframe. Multiple row variables can be specified, but only one
#' column variable.
#'
#' Respondent weighting can be applied by specifying a variable within the data
#' to weight by. Note, no sense checks are applied to the weight, so results
#' could be extreme is not used properly.
#'
#' @param dat A dataframe containing the variables to be used as rows and
#' columns in the output table.
#' @param row_vars Character vector containing the variables to be used as rows
#' in the table.
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' #' @param value_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. value - the values `dat`
#' 3. value label - the value labels of `dat`
#' As generated by \link[tveDataLoader]{get_valLabels}
#' @param percents Either "columns" for column percents, "rows" for row
#' percents or "none" for counts.
#'
#' @return Tibble containing `Variable` name, variable `Label`, variable
#' `Value`, a `Total` column and a column for each value within the specified
#' column variable.
#'
#' @importFrom rlang .data
#'
#' @export
generate_table <- function(dat,
                           row_vars,
                           col_var,
                           weight_var,
                           variable_labels,
                           value_labels,
                           percents = "columns") {

  assertthat::assert_that(is.data.frame(dat))
  assertthat::assert_that(is.character(row_vars))
  assertthat::assert_that(is.character(col_var))
  assertthat::assert_that(is.character(weight_var))
  assertthat::assert_that(is.data.frame(variable_labels))
  rlang::arg_match(percents, c("columns", "rows", "none"))


  #create data frame that detects whether multi or single code variable
  var_type <- value_labels %>%
    split(.$variable) |>
    map(
      ~distinct(.x) %>%
        {
          if(all(.$value %in% c(0, 1)) & all(.$`value label` %in% c("Yes", "No"))) {
            "MC"
          } else {
            "SC"
          }
        }
    ) |>
    bind_rows(.id = "variable") |>
    pivot_longer(everything(), names_to = "variable", values_to = "type")

  #flag numerics
  final_type <- variable_labels |>
    left_join(var_type,join_by("variable")) |>
    #detect labels that don't have anything that indicates a string in labels
    filter(!str_detect(variable,"other|respid|string|click")) |>
    filter(!str_detect(label,"other|respid|string|click")) |>
    #replace NA type with numeric flag
    mutate(type = case_when(
      is.na(type) ~ "NUM",
      TRUE ~ type
    ))

  #check there is no missing variable types
  assertthat::assert_that(sum(is.na(final_type))==0)

  #filter by variable type
  mc <- final_type |> filter(type == "MC") |> select(variable)
  single <- final_type |> filter(type == "SC") |> select(variable)
  numeric <- final_type |> filter(type == "NUM") |> select(variable)

  ##mutli and single
  combined_factor <- dplyr::select(dat, dplyr::all_of(c(row_vars, col_var, weight_var))) %>%
    # add a specific column variable in case col_var is also selected as a row
    # variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    # now reselect leaving out col_var unless it is in row_vars
    dplyr::select(dplyr::all_of(c(row_vars, weight_var)), column) %>%
    dplyr::select(dplyr::any_of(c(single$variable,mc$variable)),weight_var,column) |>
    # if labelled convert to ordered factor
    dplyr::mutate(
      dplyr::across(
        where(labelled::is.labelled) & -tidyselect::all_of(weight_var),
        ~haven::as_factor(.x, ordered = TRUE)
      )
    ) %>%
    # if not labelled then must be a numeric var, convert to factor
    # levels in ascending order
    dplyr::mutate(
      dplyr::across(
        where(~!is.factor(.x)) & -tidyselect::all_of(weight_var),
        ~factor(.x, levels = sort(unique(.x)))
      )
    ) %>%
    # add explicit NA level
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        forcats::fct_na_value_to_level
      )
    ) %>%
    # convert everything to character so that we can pivot longer
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        as.character
      )
    ) %>%
    tidyr::pivot_longer(-c(tidyselect::all_of(weight_var), column)) %>%
    # add total column
    dplyr::bind_rows(dplyr::mutate(., column = "Total")) %>%
    dplyr::group_by(dplyr::across(-tidyselect::all_of(weight_var))) %>%
    dplyr::count(wt = .data[[weight_var]]) %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(
      names_from = column,
      values_from = n
    ) %>%
    dplyr::left_join(variable_labels, by = c("name" = "variable")) %>%
    dplyr::relocate(label, .after = name) %>%
    dplyr::relocate(Total, .after = value) %>%
    # replace NA with 0
    dplyr::mutate(
      dplyr::across(-c(name, label, value), ~tidyr::replace_na(.x, 0))
    )

  #conditional section depending on whether row or col percents indicated in argument
  if(percents == "columns") {
    combined_factor <- combined_factor %>%
      dplyr::group_by(name) %>%
      dplyr::mutate(dplyr::across(-c(1:2), ~.x / sum(.x, na.rm = TRUE))) %>%
      dplyr::ungroup()
  } else if (percents == "rows") {
    combined_factor <- combined_factor %>%
      dplyr::rowwise() %>%
      dplyr::mutate(sum = sum(dplyr::c_across(-c(name:Total)))) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(dplyr::across(-c(name:value), ~.x / sum)) %>%
      dplyr::select(-sum) %>%
      dplyr::rowwise() %>%
      dplyr::mutate(Total = sum(dplyr::c_across(-c(name:Total)))) %>%
      dplyr::ungroup()
  }

  #numeric
  number_out <- dplyr::select(dat, dplyr::all_of(c(row_vars, col_var, weight_var))) %>%
    # add a specific column variable in case col_var is also selected as a row
    # variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    # now reselect leaving out col_var unless it is in row_vars
    dplyr::select(dplyr::any_of(numeric$variable), dplyr::all_of(weight_var), column) %>%
    mutate(column = as_factor(column)) |>
    # add explicit NA level
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        ~ ifelse(is.na(.), "0", as.character(.))
      )
    )|>
    tidyr::pivot_longer(-c(tidyselect::all_of(weight_var), column)) |>
    #convert value to numeric so we can calculate means
    mutate(value = as.numeric(value))

  #weighted mean table using two group vars
  group_number <- number_out |>
    group_by(name,column) |>
    summarise(value = weighted.mean(value,wt = weight)) |>
    ungroup() |>
    pivot_wider(names_from = "column",values_from = "value")

  #table using one group vars (just analysis variable)
  total_number <- number_out |>
    group_by(name) |>
    summarise(value = weighted.mean(value,wt = weight)) |>
    ungroup() |>
    rename(Total = value)

  #join them up and add label to show mean
  combined_number <- total_number |>
    dplyr::left_join(group_number,join_by("name")) |>
    left_join(variable_labels,join_by("name"=="variable")) |>
    mutate(value = "mean") |>
    select(name,label,value,everything())

  #combine the factor and numeric together - need to sort by row var
  # mutate(name =  factor(name, levels = row_vars))
  #   slice(match(x, category))

  out <- bind_rows(combined_factor,combined_number)

  #add capitals to columns
  names(out) <- c("Variable", "Label", "Value", names(out)[-c(1:3)])

  return(out)

}

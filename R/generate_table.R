#' identify variable type of input variables
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#' in the table.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' @param value_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. value - the values `dat`
#' 3. value label - the value labels of `dat`
#' As generated by \link[tveDataLoader]{get_valLabels}#'
#' @return named list containing flags for multi code, single code and numerics
#' @export
#'
#' @examples ''
#'
identify_var_type <- function(dat,
                              row_vars,
                              variable_labels,
                              value_labels) {

  #create data frame that detects whether multi or single code variable. Anything missing is either numeric or string.

  var_type <- value_labels %>%
    split(.$variable) |>
    purrr::map(
      ~dplyr::distinct(.x) %>%
        {
          if(all(.$value %in% c(0, 1)) & all(.$`value label` %in% c("Yes", "No"))) {
            "MC"
          } else {
            "SC"
          }
        }
    ) |>
    dplyr::bind_rows(.id = "variable") |>
    tidyr::pivot_longer(everything(), names_to = "variable", values_to = "type")

  #flag character vars in data frame - TRUE = character
  character_vars <- purrr::map_lgl(dat, ~ is.character(.x))

  #extract them from the data set so we can filter using it
  character_names <- names(dat)[character_vars]

  final_type <- variable_labels |>
    #drop respid
    dplyr::filter(variable != "respid") |>
    dplyr::left_join(var_type,dplyr::join_by("variable")) |>
    #flag character vars
    dplyr::mutate(type = ifelse(
      variable %in% character_names,"STRING",type)
    ) |>
    #anything else left is numeric
    dplyr::mutate(type = dplyr::case_when(
      is.na(type) ~ "NUM",
      TRUE ~ type
    ))

  #filter by variable type and row vars
  mc_flag <- final_type |> dplyr::filter(type == "MC") |> dplyr::filter(variable %in% row_vars) |> dplyr::pull(variable)
  single_flag <- final_type |> dplyr::filter(type == "SC") |> dplyr::filter(variable %in% row_vars) |> dplyr::pull(variable)
  numeric_flag <- final_type |> dplyr::filter(type == "NUM")  |> dplyr::filter(variable %in% row_vars) |> dplyr::pull(variable)

  return(list(
    mc_flag = mc_flag,
    single_flag = single_flag,
    numeric_flag = numeric_flag
  ))

}


#' calculate table for multi code and numeric questions
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#' in the table.
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' @param flag_list named list of character vectors for single code, single code and multi code
#' As generated by \link[tveTableTool]{identify_var_type}
#'
#' @return table
#' @export
#'
#' @examples ''

mean_calcs <- function(dat,
                       col_var,
                       weight_var,
                       variable_labels,
                       flag_list) {

  # Numeric and multi-code calculations - weighted means
  number_out <- dat %>%
    # Add a specific column variable in case col_var is also selected as a row variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    dplyr::mutate(column = haven::as_factor(column)) %>%
    # Now reselect leaving out col_var unless it is in row_vars
    dplyr::select(
      dplyr::all_of(
        c(
          flag_list$numeric_flag,
          flag_list$mc_flag,
          weight_var,
          "column"
          )
        )
      ) %>%
    # Add explicit NA level
    dplyr::mutate(
      dplyr::across(
        -dplyr::all_of(weight_var),
        ~ dplyr::if_else(is.na(.), "0", as.character(.))  # Use a formula function with ~
      )
    )|>
    tidyr::pivot_longer(-c(tidyselect::all_of(weight_var), column)) |>
    #convert value to numeric so we can calculate means
    dplyr::mutate(value = as.numeric(value))

  #condition to run unweighted or weighred tables
  if (is.null(weight_var) || weight_var == "") {
    # Unweighted mean calculations
    group_number <- number_out %>%
      dplyr::group_by(name, column) %>%
      dplyr::summarise(value = mean(value, na.rm = TRUE), .groups = 'drop') %>%
      tidyr::pivot_wider(names_from = "column", values_from = "value")

    total_number <- number_out %>%
      dplyr::group_by(name) %>%
      dplyr::summarise(value = mean(value, na.rm = TRUE), .groups = 'drop') %>%
      dplyr::rename(Total = value)
  } else {
    # Weighted mean calculations
    group_number <- number_out %>%
      dplyr::group_by(name, column) %>%
      dplyr::summarise(value = weighted.mean(value, w = .data[[weight_var]], na.rm = TRUE), .groups = 'drop') %>%
      tidyr::pivot_wider(names_from = "column", values_from = "value")

    total_number <- number_out %>%
      dplyr::group_by(name) %>%
      dplyr::summarise(value = weighted.mean(value, w = .data[[weight_var]], na.rm = TRUE), .groups = 'drop') %>%
      dplyr::rename(Total = value)
  }

  # Join them up and add label to show mean
  combined_number <- total_number %>%
    dplyr::left_join(group_number, by = "name") %>%
    dplyr::left_join(variable_labels, by = c("name" = "variable")) %>%
    dplyr::mutate(value = "mean") %>%
    dplyr::select(Variable = name, label, value, dplyr::everything())

  return(combined_number)

}

#' calculate table for single code questions
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#' in the table.
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param variable_labels A dataframe consisting of 2 columns:
#' 1. variable - the variable names of `dat`
#' 2. label - the variable labels of `dat`
#' As generated by \link[tveDataLoader]{get_varLabels}
#' @param flag_list named list of character vectors for single code, single code and multi code
#' As generated by \link[tveTableTool]{identify_var_type}
#'
#' @return table
#'
#' @export
#'
#' @examples ''
#'
single_calcs <- function(dat,
                         # row_vars,
                         col_var,
                         weight_var,
                         variable_labels,
                         flag_list) {

  # Prepare the data
  prep <- dat %>%
    # Add a specific column variable in case col_var is also selected as a row variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    dplyr::select(dplyr::all_of(c(flag_list$single_flag, weight_var, "column"))) %>%
    # If labelled, convert to ordered factor
    dplyr::mutate(
      dplyr::across(
        where(labelled::is.labelled) & -tidyselect::all_of(weight_var),
        ~haven::as_factor(.x, ordered = TRUE)
      )
    ) %>%
    # Add explicit NA level
    dplyr::mutate(
      dplyr::across(
        where(labelled::is.labelled) & -tidyselect::all_of(weight_var),
        ~forcats::fct_na_value_to_level(.x)
      )
    ) %>%
    # Convert everything to character so that we can pivot longer
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        as.character
      )
    ) %>%
    tidyr::pivot_longer(-c(weight_var, column),names_to = "Variable") %>%
    # Add total column
    dplyr::bind_rows(dplyr::mutate(., column = "Total"))

  # unweighted count
  if (is.null(weight_var)) {
    counted <-  prep %>%
      dplyr::group_by(dplyr::across(-tidyselect::all_of(weight_var))) %>%
      dplyr::count()
    #weighted count
  } else {
    counted <-  prep %>%
      dplyr::group_by(dplyr::across(-tidyselect::all_of(weight_var))) %>%
      dplyr::count(wt = .data[[weight_var]])
  }

    # Final transformations
  single_out <- counted %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(
      names_from = column,
      values_from = n
    ) %>%
    dplyr::left_join(variable_labels, by = c("Variable" = "variable")) %>%
    dplyr::relocate(label, .after = Variable) %>%
    dplyr::relocate(Total, .after = value) %>%
    # Replace NA with 0
    dplyr::mutate(
      dplyr::across(-c(Variable, label, value), ~tidyr::replace_na(.x, 0))
    ) %>%
    dplyr::group_by(Variable) %>%
    dplyr::mutate(dplyr::across(-c(1:2), ~.x / sum(.x, na.rm = TRUE))) %>%
    dplyr::ungroup()

  return(single_out)

}

#' wraps the 3 generate table functions into one to produce final table
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#'   in the table.
#' @param col_var Character string containing the variables to be used as
#'   columns in the output table.
#' @param weight_var Character string containing the variable name of the weight
#'   to be used.
#' @param variable_labels Either `NULL` (default) or a dataframe consisting of 2
#'   columns:
#'   1. variable - variable names from `dat`
#'   2. label - variable labels from `dat`
#'
#'   e.g. as generated by [tveDataLoader::get_varLabels()]. If `NULL`
#'   then existing variable labels will be read from `dat` using
#'   [tveDataLoader::get_varLabels()]. If a dataframe is provided then those
#'   labels will be used to replace any existing labels via
#'   [tveDataLoader::update_var_labels()]. Only the labels of variables provided
#'   will be updated, others will remain unchanged and will be used in the table
#'   as they are. As we're updating labels, every variable listed must
#'   correspond to a column in `dat`.
#' @param value_labels Either `NULL` (default) or a dataframe consisting of 3
#'   columns:
#'   1. variable - variable names from `dat`
#'   2. value - values of the variables
#'   3. value label - value labels of the values
#'
#'   e.g. as generated by [tveDataLoader::get_valLabels()]. If `NULL` then the
#'   existing value labels will be read from `dat` using
#'   [tveDataLoader::get_valLabels()]. If a dataframe is provided then those
#'   value labels will be used to replace any existing labels via
#'   [tveDataLoader::update_val_labels()]. Only the value labels of variables
#'   provided will be updated, others will remain unchanged and used in the
#'   table as they are. As we're updating labels, every variable listed must
#'   correspond to a column in `dat`.
#'
#' @return final output table
#'
#' @export
#'
#' @examples ''
#'
generate_table <- function(dat,
                           row_vars,
                           col_var,
                           weight_var,
                           variable_labels = NULL,
                           value_labels = NULL) {

  # Checks
  assertthat::assert_that(is.data.frame(dat))
  assertthat::assert_that(is.character(row_vars))
  assertthat::assert_that(is.character(col_var))
  assertthat::assert_that(is.null(weight_var) || is.character(weight_var))
  assertthat::assert_that(
    any(
      is.null(variable_labels),
      all(
        # variable_labels should be a data frame
        is.data.frame(variable_labels),
        # all variables in variable_labels should correspond to a column in dat
        all(variable_labels[[1]] %in% names(dat))
      )
    )
  )
  assertthat::assert_that(
    any(
      is.null(value_labels),
      all(
        # value_labels should be a data frame
        is.data.frame(value_labels),
        # all variables in value_labels should correspond to a column indat
        all(unique(value_labels[[1]]) %in% names(dat))
      )
    )
  )

  # if no variable / value labels provided then read them from dat, otherwise
  # update dat with the labels provided and then read all variable / value
  # labels
  if(is.null(variable_labels)) {
    variable_labels <- tveDataLoader::get_varLabels(dat)
  } else {
    variable_labels <- dat |>
      tveDataLoader::update_var_labels(variable_labels) |>
      tveDataLoader::get_varLabels()
  }
  if(is.null(value_labels)) {
    value_labels <- tveDataLoader::get_valLabels(dat)
  } else {
    value_labels <- dat |>
      tveDataLoader::update_val_labels(value_labels) |>
      tveDataLoader::get_valLabels()
  }

  # Identify variable types and flags
  flag_list <- identify_var_type(dat, row_vars, variable_labels, value_labels)

  # Conditional calculations for numeric and multi-code variables
  if (length(flag_list$numeric_flag) + length(flag_list$mc_flag) > 0) {
    # Numeric and multi-code calculations
    mean_calcs_result <- mean_calcs(
      dat,
      col_var,
      weight_var,
      variable_labels,
      flag_list
    )
  } else {
    mean_calcs_result <- NULL
  }

  # Conditional calculations for single-code variables
  if (length(flag_list$single_flag) > 0) {
    # Single code calculations
    single_calcs_result <- single_calcs(
      dat,
      # row_vars,
      col_var,
      weight_var,
      variable_labels,
      flag_list
    )
  } else {
    single_calcs_result <- NULL
  }

  # Store a log of the desired order based on input
  rows_order <- data.frame(Variable = row_vars, stringsAsFactors = FALSE)
  order_df <- rows_order |>
    dplyr::mutate(order = dplyr::row_number()) # Use row_number() to generate order

  # Join tables together and reorder
  output <- dplyr::bind_rows(mean_calcs_result, single_calcs_result) |>
    dplyr::left_join(order_df, by = "Variable") |>
    dplyr::arrange(order) |>
    dplyr::select(-order)

  # Check number of unique rows in table matches the number of row variables
  assertthat::assert_that(length(unique(output$Variable)) == length(row_vars))

  return(output)
}




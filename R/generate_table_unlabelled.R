#' identify variable type of input variables for unlabelled data
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#' in the table.
#' @return named list containing flags for numerics and categories
#' @export
#'
#' @examples ''
#'
#'
identify_var_type_unlabs <- function(dat,
                                     row_vars) {

  dat <- dat |> select(all_of(row_vars))

  #flag character vars in data frame - TRUE = character
  character_vars <- purrr::map_lgl(dat, ~ is.character(.x))
  factor_vars <- purrr::map_lgl(dat, ~ is.factor(.x))
  numeric_vars <- purrr::map_lgl(dat, ~ is.numeric(.x))


  #extract them from the data set so we can filter using it
  character_names <- names(dat)[character_vars]
  factor_names <- names(dat)[factor_vars]
  numeric_names <- names(dat)[numeric_vars]

  category_flag <- c(character_names,factor_names)
  numeric_flag <- numeric_names

  return(list(
    category_flag = category_flag,
    numeric_flag = numeric_flag
  ))

}

#' calculate table for numeric variables in unlabelled data
#'
#' @param dat data
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param flag_list named list of character vectors for numeric variables
#' As generated by \link[tveTableTool]{identify_var_type}
#'
#' @return table
#' @export
#'
#' @examples ''

mean_calcs_unlabs <- function(dat,
                              col_var,
                              weight_var,
                              flag_list) {

  # Numeric and multi-code calculations - weighted means
  number_out <- dat %>%
    # Add a specific column variable in case col_var is also selected as a row variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    dplyr::mutate(column = haven::as_factor(column)) %>%
    # Now reselect leaving out col_var unless it is in row_vars
    dplyr::select(
      dplyr::all_of(
        c(
          flag_list$numeric_flag,
          weight_var,
          "column"
        )
      )
    ) %>%
    # Add explicit NA level
    dplyr::mutate(
      dplyr::across(
        -dplyr::all_of(weight_var),
        ~ dplyr::if_else(is.na(.), "0", as.character(.))  # Use a formula function with ~
      )
    )|>
    tidyr::pivot_longer(-c(tidyselect::all_of(weight_var), column)) |>
    #convert value to numeric so we can calculate means
    dplyr::mutate(value = as.numeric(value))

  # Weighted mean calculations
  group_number <- number_out %>%
    dplyr::group_by(name, column) %>%
    dplyr::summarise(
      value = weighted.mean(value, wt = .data[[weight_var]], na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    tidyr::pivot_wider(names_from = "column", values_from = "value")

  total_number <- number_out %>%
    dplyr::group_by(name) %>%
    dplyr::summarise(
      value = weighted.mean(value, wt = .data[[weight_var]], na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    dplyr::rename(Total = value)

  # Join them up and add label to show mean
  combined_number <- total_number %>%
    dplyr::left_join(group_number, by = "name") %>%
    dplyr::mutate(value = "mean") %>%
    dplyr::select(Variable = name, value, dplyr::everything())

  return(combined_number)

}

#' calculate table for single code questions
#'
#' @param dat data
#' @param col_var Character string containing the variables to be used as
#' columns in the output table.
#' @param weight_var Character string containing the variable name of the
#' weight to be used.
#' @param flag_list named list of character vectors for category
#' As generated by \link[tveTableTool]{identify_var_type}
#'
#' @return table
#'
#' @export
#'
#' @examples ''
#'
#'

single_calcs_unlabs <- function(dat,
                                col_var,
                                weight_var,
                                flag_list) {

  # Prepare the data
  prep <- dat %>%
    # Add a specific column variable in case col_var is also selected as a row variable
    dplyr::mutate(column = .data[[col_var]]) %>%
    dplyr::select(dplyr::all_of(c(flag_list$category_flag, weight_var, "column"))) %>%
    # Convert character or factor columns to ordered factors, excluding the weight variable
    dplyr::mutate(
      dplyr::across(
        where(~ is.character(.x) | is.factor(.x)) & -tidyselect::all_of(weight_var),
        ~haven::as_factor(.x)
      )
    ) |>
    # Add explicit NA level
    dplyr::mutate(
      dplyr::across(
        dplyr::all_of(c(flag_list$category_flag)) & -tidyselect::all_of(weight_var),
        ~forcats::fct_na_value_to_level(.x)
      )
    ) %>%
    # Convert everything to character so that we can pivot longer
    dplyr::mutate(
      dplyr::across(
        -tidyselect::all_of(weight_var),
        as.character
      )
    ) %>%
    tidyr::pivot_longer(-c(weight_var, column),names_to = "Variable") %>%
    # Add total column
    dplyr::bind_rows(dplyr::mutate(., column = "Total"))

  counted <-  prep %>%
    dplyr::group_by(dplyr::across(-tidyselect::all_of(weight_var))) %>%
    dplyr::count(wt = .data[[weight_var]])

  # Final transformations
  single_out <- counted %>%
    dplyr::ungroup() %>%
    tidyr::pivot_wider(
      names_from = column,
      values_from = n
    ) %>%
    dplyr::relocate(Total, .after = value) %>%
    # Replace NA with 0
    dplyr::mutate(
      dplyr::across(-c(Variable, value), ~tidyr::replace_na(.x, 0))
    ) %>%
    dplyr::group_by(Variable) %>%
    dplyr::mutate(dplyr::across(-c(1:2), ~.x / sum(.x, na.rm = TRUE))) %>%
    dplyr::ungroup()

  return(single_out)

}

#' wraps the 3 generate table functions into one to produce final table for unlabelled data
#'
#' @param dat data
#' @param row_vars Character vector containing the variables to be used as rows
#'   in the table.
#' @param col_var Character string containing the variables to be used as
#'   columns in the output table.
#' @param weight_var Character string containing the variable name of the weight
#'   to be used.
#' @return final output table
#'
#' @export
#'
#' @examples ''
#'
#'
generate_table_unlabs <- function(dat,
                                  row_vars,
                                  col_var,
                                  weight_var = NULL) {

  # Checks
  dat_name <- deparse(substitute(dat))
  assertthat::assert_that(is.data.frame(dat))
  assertthat::assert_that(is.character(row_vars))
  row_vars_not_in_dat <- row_vars[!row_vars %in% names(dat)]
  assertthat::assert_that(
    length(row_vars_not_in_dat) == 0,
    msg = glue::glue("row_vars are missing from {dat_name}: {stringr::str_flatten_comma(row_vars_not_in_dat)}")
  )
  assertthat::assert_that(is.character(col_var))
  assertthat::assert_that(
    col_var %in% names(dat),
    msg = glue::glue("{col_var} not in {dat_name}")
  )
  assertthat::assert_that(is.null(weight_var) || is.character(weight_var))
  if(!is.null(weight_var)) {
    assertthat::assert_that(length(weight_var) == 1, msg = "Only 1 weight variable allowed")
    assertthat::assert_that(
      weight_var %in% names(dat),
      msg = glue::glue("{weight_var} not in {dat_name}")
    )
  }

  # if no weight provided (i.e. weight_var == NULL) then add a dummy weight of 1
  # and set weight_var to "weight"
  if(is.null(weight_var)) {
    dat$weight <- 1
    weight_var <- "weight"
  }

  # Identify variable types and flags
  flag_list <- identify_var_type_unlabs(dat, row_vars)

  # Conditional calculations for numeric and multi-code variables
  if (length(flag_list$numeric_flag) > 0) {
    # Numeric and multi-code calculations
    mean_calcs_result <- mean_calcs_unlabs(
      dat,
      col_var,
      weight_var,
      flag_list
    )
  } else {
    mean_calcs_result <- NULL
  }

  # Conditional calculations for single-code variables
  if (length(flag_list$category_flag) > 0) {
    # Single code calculations
    single_calcs_result <- single_calcs_unlabs(
      dat,
      col_var,
      weight_var,
      flag_list
    )
  } else {
    single_calcs_result <- NULL
  }

  # Store a log of the desired order based on input
  rows_order <- data.frame(Variable = row_vars, stringsAsFactors = FALSE)
  order_df <- rows_order |>
    dplyr::mutate(order = dplyr::row_number()) # Use row_number() to generate order

  # Join tables together and reorder
  output <- dplyr::bind_rows(mean_calcs_result, single_calcs_result) |>
    dplyr::left_join(order_df, by = "Variable") |>
    dplyr::arrange(order) |>
    dplyr::select(-order)

  #make sure column names have correct capitalizstion for segmentation profiling functions
  names(output) <- c("Variable", "Value", names(output)[-c(1:2)])

  # Check number of unique rows in table matches the number of row variables
  # assertthat::assert_that(length(unique(output$Variable)) == length(row_vars))

  return(output)

}
